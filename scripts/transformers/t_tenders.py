#
# año 2022
#
# {
#   "sello": 62665,
#   "urlSuscripciones": 62665,
#   "urlSuscripcionesPoder": 62665,
#   "firstPublicationDate": 62665,
#   "contractingAuthority": 62665,
#       ["{'id': '1'}", "{'id': '10'}", "{'id': '100'}", "{'id': '101'}", "{'id': '102'}", "{'id': '103'}", "{'id': '104'}", "{'id': '105'}", "{'id': '106'}", "{'id': '107'}", "{'id': '108'}", "{'id': '109'}", "{'id': '112'}", "{'id': '113'}", "{'id': '114'}", "{'id': '115'}", "{'id': '116'}", "{'id': '117'}", "{'id': '119'}", "{'id': '120'}", "{'id': '121'}", "{'id': '122'}", "{'id': '123'}", "{'id': '124'}", "{'id': '126'}", "{'id': '127'}", "{'id': '128'}", "{'id': '129'}", "{'id': '130'}", "{'id': '132'}", "{'id': '133'}", "{'id': '135'}", "{'id': '137'}", "{'id': '138'}", "{'id': '139'}", "{'id': '140'}", "{'id': '141'}", "{'id': '142'}", "{'id': '143'}", "{'id': '144'}", "{'id': '145'}", "{'id': '146'}", "{'id': '147'}", "{'id': '148'}", "{'id': '149'}", "{'id': '150'}", "{'id': '151'}", "{'id': '152'}", "{'id': '153'}", "{'id': '155'}", "{'id': '156'}", "{'id': '157'}", "{'id': '159'}", "{'id': '160'}", "{'id': '161'}", "{'id': '162'}", "{'id': '165'}", "{'id': '166'}", "{'id': '167'}", "{'id': '168'}", "{'id': '169'}", "{'id': '171'}", "{'id': '172'}", "{'id': '173'}", "{'id': '174'}", "{'id': '175'}", "{'id': '176'}", "{'id': '177'}", "{'id': '178'}", "{'id': '179'}", "{'id': '180'}", "{'id': '183'}", "{'id': '184'}", "{'id': '185'}", "{'id': '187'}", "{'id': '188'}", "{'id': '19'}", "{'id': '190'}", "{'id': '192'}", "{'id': '193'}", "{'id': '194'}", "{'id': '195'}", "{'id': '197'}", "{'id': '198'}", "{'id': '199'}", "{'id': '2'}", "{'id': '200'}", "{'id': '202'}", "{'id': '203'}", "{'id': '204'}", "{'id': '205'}", "{'id': '206'}", "{'id': '207'}", "{'id': '21'}", "{'id': '210'}", "{'id': '213'}", "{'id': '214'}", "{'id': '215'}", "{'id': '216'}", "{'id': '217'}", "{'id': '218'}", "{'id': '219'}", "{'id': '22'}", "{'id': '220'}", "{'id': '221'}", "{'id': '222'}", "{'id': '223'}", "{'id': '22339'}", "{'id': '224'}", "{'id': '225'}", "{'id': '226'}", "{'id': '227'}", "{'id': '228'}", "{'id': '229'}", "{'id': '23'}", "{'id': '230'}", "{'id': '232'}", "{'id': '233'}", "{'id': '239'}", "{'id': '24'}", "{'id': '240'}", "{'id': '241'}", "{'id': '242'}", "{'id': '243'}", "{'id': '244'}", "{'id': '24419'}", "{'id': '24453'}", "{'id': '24477'}", "{'id': '245'}", "{'id': '24519'}", "{'id': '24523'}", "{'id': '24527'}", "{'id': '24542'}", "{'id': '24548'}", "{'id': '24555'}", "{'id': '24559'}", "{'id': '24566'}", "{'id': '24580'}", "{'id': '24589'}", "{'id': '24596'}", "{'id': '246'}", "{'id': '24605'}", "{'id': '24609'}", "{'id': '24629'}", "{'id': '24634'}", "{'id': '247'}", "{'id': '248'}", "{'id': '24987'}", "{'id': '250'}", "{'id': '251'}", "{'id': '25135'}", "{'id': '25142'}", "{'id': '252'}", "{'id': '253'}", "{'id': '254'}", "{'id': '25439'}", "{'id': '25445'}", "{'id': '25456'}", "{'id': '25484'}", "{'id': '255'}", "{'id': '25512'}", "{'id': '25523'}", "{'id': '25528'}", "{'id': '25532'}", "{'id': '25573'}", "{'id': '256'}", "{'id': '258'}", "{'id': '259'}", "{'id': '260'}", "{'id': '261'}", "{'id': '262'}", "{'id': '263'}", "{'id': '264'}", "{'id': '265'}", "{'id': '266'}", "{'id': '267'}", "{'id': '268'}", "{'id': '269'}", "{'id': '271'}", "{'id': '272'}", "{'id': '273'}", "{'id': '274'}", "{'id': '276'}", "{'id': '278'}", "{'id': '280'}", "{'id': '281'}", "{'id': '282'}", "{'id': '283'}", "{'id': '284'}", "{'id': '285'}", "{'id': '288'}", "{'id': '289'}", "{'id': '290'}", "{'id': '291'}", "{'id': '292'}", "{'id': '294'}", "{'id': '296'}", "{'id': '298'}", "{'id': '299'}", "{'id': '30'}", "{'id': '300'}", "{'id': '301'}", "{'id': '302'}", "{'id': '303'}", "{'id': '304'}", "{'id': '305'}", "{'id': '306'}", "{'id': '307'}", "{'id': '309'}", "{'id': '312'}", "{'id': '313'}", "{'id': '314'}", "{'id': '315'}", "{'id': '316'}", "{'id': '317'}", "{'id': '318'}", "{'id': '319'}", "{'id': '320'}", "{'id': '321'}", "{'id': '322'}", "{'id': '323'}", "{'id': '324'}", "{'id': '325'}", "{'id': '326'}", "{'id': '328'}", "{'id': '329'}", "{'id': '330'}", "{'id': '331'}", "{'id': '332'}", "{'id': '333'}", "{'id': '335'}", "{'id': '336'}", "{'id': '338'}", "{'id': '340'}", "{'id': '341'}", "{'id': '342'}", "{'id': '344'}", "{'id': '349'}", "{'id': '350'}", "{'id': '352'}", "{'id': '353'}", "{'id': '354'}", "{'id': '355'}", "{'id': '356'}", "{'id': '358'}", "{'id': '359'}", "{'id': '360'}", "{'id': '361'}", "{'id': '362'}", "{'id': '364'}", "{'id': '365'}", "{'id': '366'}", "{'id': '367'}", "{'id': '368'}", "{'id': '369'}", "{'id': '37'}", "{'id': '370'}", "{'id': '371'}", "{'id': '372'}", "{'id': '374'}", "{'id': '375'}", "{'id': '376'}", "{'id': '378'}", "{'id': '379'}", "{'id': '38'}", "{'id': '380'}", "{'id': '381'}", "{'id': '382'}", "{'id': '383'}", "{'id': '384'}", "{'id': '385'}", "{'id': '386'}", "{'id': '387'}", "{'id': '388'}", "{'id': '39'}", "{'id': '390'}", "{'id': '392'}", "{'id': '393'}", "{'id': '394'}", "{'id': '397'}", "{'id': '398'}", "{'id': '399'}", "{'id': '40'}", "{'id': '400'}", "{'id': '401'}", "{'id': '402'}", "{'id': '403'}", "{'id': '404'}", "{'id': '405'}", "{'id': '407'}", "{'id': '408'}", "{'id': '409'}", "{'id': '410'}", "{'id': '412'}", "{'id': '413'}", "{'id': '414'}", "{'id': '415'}", "{'id': '416'}", "{'id': '417'}", "{'id': '418'}", "{'id': '419'}", "{'id': '42'}", "{'id': '420'}", "{'id': '422'}", "{'id': '423'}", "{'id': '427'}", "{'id': '428'}", "{'id': '430'}", "{'id': '431'}", "{'id': '432'}", "{'id': '433'}", "{'id': '435'}", "{'id': '436'}", "{'id': '437'}", "{'id': '44'}", "{'id': '440'}", "{'id': '442'}", "{'id': '443'}", "{'id': '444'}", "{'id': '445'}", "{'id': '446'}", "{'id': '447'}", "{'id': '448'}", "{'id': '449'}", "{'id': '45'}", "{'id': '450'}", "{'id': '452'}", "{'id': '454'}", "{'id': '455'}", "{'id': '456'}", "{'id': '457'}", "{'id': '458'}", "{'id': '459'}", "{'id': '46'}", "{'id': '460'}", "{'id': '462'}", "{'id': '463'}", "{'id': '467'}", "{'id': '468'}", "{'id': '47'}", "{'id': '471'}", "{'id': '472'}", "{'id': '474'}", "{'id': '476'}", "{'id': '479'}", "{'id': '48'}", "{'id': '483'}", "{'id': '486'}", "{'id': '488'}", "{'id': '490'}", "{'id': '493'}", "{'id': '498'}", "{'id': '500'}", "{'id': '502'}", "{'id': '506'}", "{'id': '507'}", "{'id': '508'}", "{'id': '511'}", "{'id': '518'}", "{'id': '522'}", "{'id': '524'}", "{'id': '526'}", "{'id': '527'}", "{'id': '528'}", "{'id': '53'}", "{'id': '534'}", "{'id': '54'}", "{'id': '541'}", "{'id': '543'}", "{'id': '544'}", "{'id': '548'}", "{'id': '55'}", "{'id': '551'}", "{'id': '552'}", "{'id': '553'}", "{'id': '554'}", "{'id': '557'}", "{'id': '558'}", "{'id': '559'}", "{'id': '562'}", "{'id': '563'}", "{'id': '565'}", "{'id': '569'}", "{'id': '57'}", "{'id': '570'}", "{'id': '571'}", "{'id': '576'}", "{'id': '581'}", "{'id': '59'}", "{'id': '591'}", "{'id': '592'}", "{'id': '594'}", "{'id': '599'}", "{'id': '6'}", "{'id': '60'}", "{'id': '603'}", "{'id': '604'}", "{'id': '61'}", "{'id': '612'}", "{'id': '615'}", "{'id': '616'}", "{'id': '619'}", "{'id': '62'}", "{'id': '622'}", "{'id': '625'}", "{'id': '629'}", "{'id': '64'}", "{'id': '643'}", "{'id': '644'}", "{'id': '648'}", "{'id': '650'}", "{'id': '654'}", "{'id': '66'}", "{'id': '662'}", "{'id': '669'}", "{'id': '67'}", "{'id': '674'}", "{'id': '68'}", "{'id': '684'}", "{'id': '686'}", "{'id': '69'}", "{'id': '690'}", "{'id': '692'}", "{'id': '703'}", "{'id': '704'}", "{'id': '707'}", "{'id': '71'}", "{'id': '711'}", "{'id': '712'}", "{'id': '72'}", "{'id': '73'}", "{'id': '731'}", "{'id': '735'}", "{'id': '74'}", "{'id': '744'}", "{'id': '751'}", "{'id': '755'}", "{'id': '758'}", "{'id': '763'}", "{'id': '77'}", "{'id': '775'}", "{'id': '79'}", "{'id': '797'}", "{'id': '8'}", "{'id': '80'}", "{'id': '81'}", "{'id': '82'}", "{'id': '85'}", "{'id': '86'}", "{'id': '88'}", "{'id': '89'}", "{'id': '91'}", "{'id': '92'}", "{'id': '93'}", "{'id': '94'}", "{'id': '96'}", "{'id': '97'}", "{'id': '98'}", "{'id': '99'}"]
#       459
#   "entityDriving": 62665,
#   "subject": 62665,
#   "placeExecutionInEU": 62665,
#   "flags": 62665,
#   "specialClauses": 62665,
#   "systemsStreamliningRecruitment": 62665,
#   "trazability": 62665,
#   "isPlazoCerrado": 62665,
#   "isPreviousAnnouncement": 62665,
#   "groupedAnnouncement": 62665,
#   "contractingBody": 62663,
#   "authorityType": 62663,
#   "mainActivity": 62663,
#   "placeExecutionNUTS": 62657,
#   "contractPeriodType": 62634,
#   "adjudicationProcedure": 62630,
#   "contractingType": 62629,
#   "codExp": 62553,
#   "processingStatus": 62553,
#   "processing": 62505,
#   "biddersNumber": 62229,
#   "pymeNumOffers": 62229,
#   "otherEstatesNumOffers": 62229,
#   "thirdCountriesNumOffers": 62229,
#   "electronicallyNumOffers": 62229,
#   "budgetWithVAT": 60542,
#   "resolutions": 60536,
#   "contractPeriod": 60456,
#   "languages": 60247,
#   "offersManagement": 60225,
#   "formalizations": 59620,
#   "adjudicationCriteria": 57834,
#   "budgetWithoutVAT": 34008,
#   "vats": 25274,
#   "historic": 22210,
#   "lastPublicationDate": 22209,
#   "cpvs": 14308,
#   "urlTodosFicheros": 9287,
#   "offerMaintenancePeriodType": 8849,
#   "offerMaintenancePeriod": 8777,
#   "expFiles": 8537,
#   "budgetEstimated": 7781,
#   "technicalContactInfo": 7553,
#   "resourceBodies": 7533,
#   "sheetModeAccess": 6856,
#   "communication": 6252,
#   "presentationPlaces": 6028,
#   "adminContactInfo": 5989,
#   "deadlineSubmissionOffer": 5966,
#   "escrowOpeningFormulas": 5393,
#   "webPageTender": 5366,
#   "selectionCriteriasCost": 5116,
#   "resolutionFiles": 5059,
#   "entityProcessing": 4632,
#   "scheduledPublicationDate": 4308,
#   "contractingTable": 4202,
#   "escrowOpeningValueJudgments": 3706,
#   "contractingTableComponents": 3672,
#   "minQuorumOpening": 3672,
#   "escrowOpeningCapacitySolvency": 3626,
#   "guaranteeAmountDef": 3367,
#   "otherTypePower": 3061,
#   "selectionCriteriasQuality": 2869,
#   "committeeTableAgreements": 2819,
#   "numberExtensions": 2692,
#   "descExtensions": 2669,
#   "contractInitialDate": 2178,
#   "contractEndDate": 2178,
#   "typeOfferLots": 1980,
#   "othersPlank": 1950,
#   "urlFicherosModelo": 1925,
#   "urlBuyer": 1273,
#   "resourcesPresentationServices": 1254,
#   "previousDOUENumber": 1226,
#   "deadlineContact": 1219,
#   "sheetSpecifications": 1145,
#   "observations": 1049,
#   "otherActivity": 1030,
#   "lots": 941,
#   "economicSolvencyCriterion": 927,
#   "unitaryPrices": 912,
#   "technicalSolvencyCriterion": 878,
#   "documentAccessPeople": 726,
#   "justification": 690,
#   "publicationsDOUE": 664,
#   "infoTermResource": 663,
#   "preparatoryPerformances": 549,
#   "observationsBudget": 537,
#   "contractPerformanceConditions": 504,
#   "linkToTender": 426,
#   "minimumEconomicLevel": 264,
#   "contractDescriptionLinkedAM": 219,
#   "maxNumberLotsPerLicitor": 207,
#   "minimumTechnicalLevel": 181,
#   "idProject": 170,
#   "maxNumberLots": 165,
#   "financingPercentage": 156,
#   "previousAnnouncementType": 114,
#   "previousAnnouncementTypeString": 114,
#   "previousAnnouncementState": 111,
#   "expertsComittee": 102,
#   "professionalQualification": 98,
#   "limitWarrantyDate": 96,
#   "previousDOUEFormalizationNumber": 94,
#   "contractDescriptionLinkedAP": 86,
#   "legalProvisionReference": 84,
#   "remedies": 77,
#   "estimatedDateInvite": 76,
#   "offerMaintenanceDate": 72,
#   "scheduledShippingDOUEDate": 69,
#   "metCalculate": 67,
#   "expertsComitteeFile": 66,
#   "guaranteeAmountProv": 64,
#   "applicationAssumptions": 61,
#   "expectedDates": 56,
#   "deliverySchedule": 49,
#   "appealFiles": 46,
#   "effectiveEndDate": 44,
#   "resources": 42,
#   "publicationsBOTH": 36,
#   "operatorsAM": 35,
#   "numberVariants": 35,
#   "assumptionDetail": 30,
#   "resourcesInfo": 29,
#   "expectedNumberCandidates": 26,
#   "publicationsBOE": 18,
#   "urlTools": 18,
#   "minNumberCandidates": 17,
#   "maxNumberCandidates": 15,
#   "estimatedSchedule": 15,
#   "righToAwardLots": 14,
#   "publicationsBOPV": 13,
#   "othersPowers": 11,
#   "additionalInformationElectronicAuction": 10,
#   "numberCandidatesCriteria": 9,
#   "internalNotes": 6,
#   "contractObjectVariants": 5,
#   "numOperatorsAM": 5,
#   "contestType": 4,
#   "numImpAwards": 3,
#   "infoContrConj": 1,
#   "contractsFrequency": 1
# }
#
# """


import json
import os
import pprint
import xml.etree.ElementTree as ET
from datetime import datetime
from html import unescape
from html.parser import HTMLParser

from bs4 import BeautifulSoup


class MyHTMLParser(HTMLParser):
    """ Used to decode html text"""

    def __init__(self):
        HTMLParser.__init__(self)
        self.reset()
        self.HTMLDATA = []

    def handle_starttag(self, tag, attrs):
        pass

    def handle_endtag(self, tag):
        pass

    def handle_data(self, data):
        self.HTMLDATA = data


def clean_xml_text(text):
    """ Process xml data """
    # Handle html encoded data
    text = unescape(text)
    parser = MyHTMLParser()
    parser.feed(text)
    text = parser.HTMLDATA

    # Handle line breaks
    text = text.replace('\n', '').replace('\xa0', ' ')

    # Handle € values
    text = text.replace('euros', '€').replace('EUROS', '€').replace(' €', '').replace('€', '')

    # Handle numbers
    try:
        text = float(text.replace('.', '').replace(',', '.'))
    except:
        pass

    # Handle dates
    try:
        text = datetime.strftime(datetime.strptime(text, "%d/%m/%Y"), "%Y-%m-%d")
    except:
        pass

    # Handle `false` values
    if text in ('N', 'No'):
        return False

    # Handle `true` values
    if text in ('S', 'Si'):
        return True

    # Handle `null` values
    if text in ('',):
        return None

    return text


def xml_parser_type_1(node, d, path=None):
    """
    v1_parser
    Los item tienen siempre un atributo, que marca la key.
    Los item pueden tener varios values.
    Los values pueden tener varios items, pero no repetidos.
    Los value pueden ser un texto o varios items.

    Implementación:
    Root. Primer nivel tiene varios items.
        Los items son distintos.
            Iterar sobre los hijos de root

        Hay items duplicados.
            Separar hijos de root duplicados
            Separar hijos de root no duplicados
    """
    if node.tag == 'item':
        item = node
        item_name = item.attrib['name']
        new_path = '-'.join((path, item_name))
        if len(item) >= 2:
            container = []
            for value_child in item:
                dd = {}
                xml_parser_type_1(value_child, dd, '')
                container.append(dd.copy())
            d[new_path] = container
        else:
            for value_child in item:
                xml_parser_type_1(value_child, d, new_path)

    elif node.tag == 'value':
        value = node
        if value.text and value.text.replace('\n', ''):
            d[path] = clean_xml_text(value.text)
        else:
            for item_child in value:
                xml_parser_type_1(item_child, d, path)

    else:
        for child in node:
            xml_parser_type_1(child, d, node.tag)


def parse_xml_contract(filepath):
    if not os.path.isfile(filepath):
        return

    filename = filepath.split(os.sep)[-2]
    year = filepath.split(os.sep)[-4]

    root = ET.parse(filepath).getroot()
    # URL = "http://opendata.euskadi.eus/contenidos/contratacion/co_53_08/es_co_06_07/data/es_r01dpd01195238155c137f0c0dc0e232c3f2753bc"
    # root = ET.fromstring(requests.get(URL).content)
    parsed_xml = {}
    xml_parser_type_1(root, parsed_xml)
    pprint.pprint(parsed_xml)
    with open('prueba.json', "w", encoding='utf-8') as f:
        f.write(json.dumps(parsed_xml, indent=2, sort_keys=True, ensure_ascii=False))


def check_field_in_xml():
    return NotImplementedError


def count_entries(sample_size):
    times_d = {}
    i = 0
    for xml_file in os.listdir(DATA_PATH):
        i += 1
        with open(os.path.join(DATA_PATH, xml_file), mode='r', encoding='utf8') as file:
            xml_file = file.read()
            soup = BeautifulSoup(xml_file, 'xml')
            for child in soup.find('contracting').children:
                if child.text:
                    tag = child.name
                    if times_d.get(tag):
                        times_d[tag] += 1
                    else:
                        times_d[tag] = 1
        if i == sample_size:
            break

    times_d = {k: v for k, v in sorted(times_d.items(), reverse=True, key=lambda item: item[1])}
    print(json.dumps(times_d, indent=2, ensure_ascii=False))


def find_entry_possible_values(sample_size, tag_name):
    vals = []
    i = 0
    for xml_file in os.listdir(DATA_PATH):
        i += 1
        with open(os.path.join(DATA_PATH, xml_file), mode='r', encoding='utf8') as file:
            xml_file = file.read()
            soup = BeautifulSoup(xml_file, 'xml')
            container = soup.find(tag_name)
            # print(container.attrs)
            try:
                if container.attrs:
                    vals.append(str(container.attrs))
            except AttributeError:
                pass

        if i == sample_size:
            break
    vals = set(vals)
    print(f"Values {sorted(vals)}")
    print(f"Len {len(vals)}")
    print()


def parse_files_2022():
    for xml_file in os.listdir(DATA_PATH):
        print(xml_file)
        with open(os.path.join(DATA_PATH, xml_file), mode='r', encoding='UTF-8') as file:
            xml_file = file.read().replace('encoding="ISO-8859-1"', 'encoding="utf8"')
            soup = BeautifulSoup(xml_file, 'xml')
            url_id = soup.find('contractingAnnouncement')['id']
            d = {}
            d['url'] = f"https://www.contratacion.euskadi.eus/w32-kpeperfi/es/contenidos/anuncio_contratacion/{url_id}/es_doc/index.html"
            contracting = soup.find('contracting')
            parse_cpv_2022(contracting, d)
            parse_driving_entity(contracting, d)
            parse_flags_2022(contracting, d)
            parse_simple_id_2022(contracting, d)
            parse_budget_2022(contracting, d)
            parse_execution_place_2022(contracting, d)
            parse_contracting_table_2022(contracting, d)
            parse_contracting_body(contracting, d)
            parse_execution_place_2022(contracting, d)
            parse_simple_text_2022(contracting, d)

        print(json.dumps(d, indent=2,ensure_ascii=False))

def parse_simple_text_2022(container, d):
    text_entries = [
        # "idExpOrigen",
        "firstPublicationDate",
        "codExp",
        "contractPeriod",
        "contractPeriodType",
        "offerMaintenancePeriod",
        "offerMaintenancePeriodType",
        "processingStatus",
        "contractingType"
        "subject",
        "processing",
        "adjudicationProcedure"

    ]
    for tag in text_entries:
        try:
            d[tag] = container.find(tag).text
        except AttributeError:
            pass


def parse_simple_id_2022(container, d):
    id_entries = [
        "contractingAuthority",
        "entityDriving",
        "contractingBody",
        "contractPeriodType",
        "contractingType"
    ]

    for tag in id_entries:
        try:
            d[tag] = container.find(tag)["id"]
        except TypeError:
            pass


def parse_execution_place_2022(container, d):
    exec_d = {}
    try:
        exec_d['inEU'] = container.find('placeExecutioninEU').find('placeExecution').text
    except AttributeError:
        pass
    try:
        exec_list = []
        for exec_place in container.find('placeExecutionNUTS').children():
            exec_p_d = {"NUTS": exec_place.find('placeExecution')["id"],
                        "is_main": exec_place.find('placeExecution').find("main").text}
            exec_list.append(exec_p_d)
        exec_d['placesExecution'] = exec_list
    except TypeError:
        pass

    d['placeExecution'] = exec_d


def parse_flags_2022(container, d):
    try:
        for flag in container.find("flags").children():
            d[f"flag_{flag['id']}"] = flag.text
    except (TypeError, AttributeError):
        pass



def parse_cpv_2022(container, d):
    cpv_list = []
    for cpv_container in container.find('cpvs'):
        cpv_list.append(cpv_container["id"])
    d['cpvs'] = cpv_list


def parse_driving_entity(container, d):
    driving_entity_d = {}
    try:
        driving_entity_d["entityDriving_id"] = container.find("entityDriving")["id"]
        driving_entity_d["entityDriving_name"] = container.find("entityDriving").find("name").text
        driving_entity_d["entityDriving_address"] = container.find("entityDriving").find("address").text
    except AttributeError or TypeError:
        pass
    d["drivingEntity"] = driving_entity_d


def parse_processing_entity(container, d):
    driving_entity_d = {}
    try:
        driving_entity_d["entityProcessing_id"] = container.find("entityProcessing")["id"]
        driving_entity_d["entityProcessing_name"] = container.find("entityProcessing").find("name").text
    except AttributeError or TypeError:
        pass
    d["drivingEntity"] = driving_entity_d


def parse_contracting_body(container, d):
    driving_entity_d = {}
    try:
        driving_entity_d["contractingBody_id"] = container.find("contractingBody")["id"]
        driving_entity_d["contractingBody_name"] = container.find("contractingBody").find("name").text
    except (AttributeError, TypeError):
        pass
    d["drivingEntity"] = driving_entity_d


def parse_budget_2022(container, d):
    text_entries = \
        [
            "budgetWithoutVAT",
            "budgetWithVAT",
            "budgetEstimated",
        ]
    budget_d = {}
    for tag in text_entries:
        try:
            budget_d[tag] = container.find(tag).text
        except AttributeError:
            pass
    d['budget'] = budget_d


def parse_contracting_table_2022(container, d):
    ctable_d = {}
    try:
        ctable_d["contractingTable_id"] = container.find("contractingTable")["id"]
    except (AttributeError,  TypeError):
        pass

    try:
        comp_list = []
        for component in container.find("contractingTableComponents").children():
            comp_d = {}
            comp_d["comp_id"] = component.find("contact")["id"]
            comp_d["comp_name"] = component.find("contact").find("name").text
            comp_d["comp_function"] = component.find("contact").find("function").text
            comp_d["comp_email"] = component.find("contact").find("email").text
            comp_list.append(comp_d)
        ctable_d["contractingTable_components"] = comp_list
        d['contractingTable'] = ctable_d
    except (AttributeError,  TypeError):
        pass



if __name__ == "__main__":
    TIME_STAMP = datetime.now().strftime("%Y%m%d")
    DATA_PATH = os.path.join(os.getcwd(), '..', '..', 'data', '20220607', 'tenders', 'raw_xml_tenders')
    parse_files_2022()
